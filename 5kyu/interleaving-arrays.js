// Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.

// Examples:

// interleave([1, 2, 3], ["c", "d", "e"]) === [1, "c", 2, "d", 3, "e"]
// interleave([1, 2, 3], [4, 5]) === [1, 4, 2, 5, 3, null]
// interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) === [1, 4, 7, 2, 5, 8, 3, 6, 9]
// interleave([]) === []

// My Soluton
function interleave(...args) {
    if(args.length==1) return args.flat();
    let ans = [];
    let n = 0;
    args.forEach(e=>{if(e.length>n) n = e.length});
    let i =0;
    while(i<n){
        for(let j=0;j<args.length;j++){
            let element;
            if(args[j][i]==0){
                element =args[j][i];
            }else{
                element = args[j][i] || null;
            };
            ans.push(element);
        };
        i++;
    };
    return ans;
};

// Solution
const interleave = (...a) => {
    let interleaved = []
    const longest = a.reduce((a, b) => (a.length > b.length ? a : b));
  
    for (let i in longest) {
      a.forEach(word => word[i] === undefined ? interleaved.push(null) : interleaved.push(word[i]));
    }
    return interleaved;
  };